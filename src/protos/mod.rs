use uuid::Uuid;

// generated by protobuf_codegen
include!(concat!(env!("OUT_DIR"), "/protos/mod.rs"));

use crate::error::Error;

/// Represents a type that can be serialized as a message.
pub trait Serialize<M>
where
    M: protobuf::Message,
{
    /// Serializes as a message.
    fn serialize(&self) -> Result<M, Error>;
}

impl Serialize<database::Uuid> for Uuid {
    fn serialize(&self) -> Result<database::Uuid, Error> {
        let mut uuid = database::Uuid::new();
        (uuid.upper, uuid.lower) = self.as_u64_pair();
        Ok(uuid)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn database_can_be_newed() {
        let db = database::Database::new();
        assert_eq!(db.vector_size, 0);
        assert_eq!(db.num_partitions, 0);
        assert_eq!(db.num_divisions, 0);
        assert_eq!(db.num_codes, 0);
        assert!(db.partition_refs.is_empty());
        assert!(db.codebook_refs.is_empty());
    }

    #[test]
    fn partition_can_be_newed() {
        let partition = database::Partition::new();
        assert_eq!(partition.vector_size, 0);
        assert_eq!(partition.num_divisions, 0);
        assert_eq!(partition.num_vectors, 0);
        assert!(partition.centroid.is_empty());
        assert!(partition.encoded_vectors.is_empty());
        assert!(partition.vector_ids.is_empty());
    }

    #[test]
    fn codebook_can_be_newed() {
        let codebook = database::Codebook::new();
        assert_eq!(codebook.vector_size, 0);
        assert_eq!(codebook.num_codes, 0);
        assert!(codebook.codes.is_empty());
    }

    #[test]
    fn uuid_can_be_serialized() {
        let upper: u64 = 0xa1a2a3a4b1b2c1c2;
        let lower: u64 = 0xd1d2d3d4d5d6d7d8;
        let uuid = Uuid::from_u64_pair(upper, lower);
        let serialized = uuid.serialize().unwrap();
        assert_eq!(serialized.upper, upper);
        assert_eq!(serialized.lower, lower);
    }
}
